diff --git a/src/cpu/pred/BranchPredictor.py b/src/cpu/pred/BranchPredictor.py
index c6abebb6a..2e1a3ea95 100644
--- a/src/cpu/pred/BranchPredictor.py
+++ b/src/cpu/pred/BranchPredictor.py
@@ -67,6 +67,14 @@ class BranchPredictor(SimObject):
     indirectBranchPred = Param.IndirectPredictor(SimpleIndirectPredictor(),
       "Indirect branch predictor, set to NULL to disable indirect predictions")
 
+class GShareBP(BranchPredictor):
+    type = 'GShareBP'
+    cxx_class = 'gem5::branch_prediction::GShareBP'
+    cxx_header = "cpu/pred/gshare.hh"
+
+    localPredictorSize = Param.Unsigned(1024, "Size of local predictor")
+    localCtrBits = Param.Unsigned(2, "Bits per counter")
+
 class LocalBP(BranchPredictor):
     type = 'LocalBP'
     cxx_class = 'gem5::branch_prediction::LocalBP'
diff --git a/src/cpu/pred/SConscript b/src/cpu/pred/SConscript
index 0437bda0f..1e64de3e0 100644
--- a/src/cpu/pred/SConscript
+++ b/src/cpu/pred/SConscript
@@ -44,7 +44,7 @@ SimObject('BranchPredictor.py', sim_objects=[
     'MultiperspectivePerceptronTAGE', 'MPP_StatisticalCorrector_64KB',
     'MultiperspectivePerceptronTAGE64KB', 'MPP_TAGE_8KB',
     'MPP_LoopPredictor_8KB', 'MPP_StatisticalCorrector_8KB',
-    'MultiperspectivePerceptronTAGE8KB'])
+    'MultiperspectivePerceptronTAGE8KB', 'GShareBP'])
 
 DebugFlag('Indirect')
 Source('bpred_unit.cc')
@@ -69,6 +69,7 @@ Source('statistical_corrector.cc')
 Source('tage_sc_l.cc')
 Source('tage_sc_l_8KB.cc')
 Source('tage_sc_l_64KB.cc')
+Source('gshare.cc')
 DebugFlag('FreeList')
 DebugFlag('Branch')
 DebugFlag('Tage')
diff --git a/src/cpu/pred/gshare.cc b/src/cpu/pred/gshare.cc
new file mode 100644
index 000000000..9aa8bf4c8
--- /dev/null
+++ b/src/cpu/pred/gshare.cc
@@ -0,0 +1,149 @@
+#include "cpu/pred/gshare.hh"
+
+#include "base/intmath.hh"
+#include "base/logging.hh"
+#include "base/trace.hh"
+#include "debug/Fetch.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+GShareBP::GShareBP(const GShareBPParams &params)
+    : BPredUnit(params),
+      localPredictorSize(params.localPredictorSize), // set local predictor size
+      localCtrBits(params.localCtrBits), // set localCtrBits
+      localCtrs(localPredictorSize, SatCounter8(localCtrBits)),
+      globalHistory(params.numThreads, 0),
+      globalHistoryBits(ceilLog2(params.localPredictorSize)) // Set global instory bits to log2(localPredictorSize)
+{
+    if (!isPowerOf2(localPredictorSize)) {
+        fatal("Invalid local predictor size!\n");
+    }
+
+    DPRINTF(Fetch, "local predictor size: %i\n",
+            localPredictorSize);
+
+    DPRINTF(Fetch, "local counter bits: %i\n", localCtrBits);
+
+    DPRINTF(Fetch, "Global History Bits $i\n", globalHistoryBits);
+
+    DPRINTF(Fetch, "instruction shift amount: %i\n",
+            instShiftAmt);
+
+    globalHistoryMask = mask(this->globalHistoryBits);
+
+    localThreshold  = (1ULL << (localCtrBits  - 1)) - 1;
+}
+
+/**
+* If a branch is not taken, because the BTB address is invalid or missing,
+* this function sets the appropriate counter in the global and local
+* predictors to not taken.
+* @param inst_PC The PC to look up the local predictor.
+* @param bp_history Pointer that will be set to an object that
+* has the branch predictor state associated with the lookup.
+*/
+void
+GShareBP::btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    //Update Global History to Not Taken (clear LSB)
+    globalHistory[tid] &= (globalHistoryMask & ~1ULL);
+}
+
+
+/**
+ * Looks up a given PC in the BP to see if it is taken or not taken.
+ * @param inst_PC The PC to look up.
+ * @param bp_history Pointer that will be set to an object that
+ * has the branch predictor state associated with the lookup.
+ * @return Whether the branch is taken or not taken.
+ */
+bool
+GShareBP::lookup(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    // TODO
+    return false;
+}
+
+/**
+* Updates the BP with taken/not taken information.
+* @param inst_PC The branch's PC that will be updated.
+* @param taken Whether the branch was taken or not taken.
+* @param bp_history Pointer to the branch predictor state that is
+* associated with the branch lookup that is being updated.
+* @param squashed Set to true when this function is called during a
+* squash operation.
+* @param inst Static instruction information
+* @param corrTarget The resolved target of the branch (only needed
+* for squashed branches)
+*/
+void
+GShareBP::update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr corrTarget)
+{
+    if(bp_history) {
+        // TODO:
+    }
+}
+
+/**
+ * Returns if the branch should be taken or not, given a counter
+ * value.
+ * @param count The counter value.
+ */
+inline
+bool
+GShareBP::getPrediction(uint8_t &count) {
+    return count > localThreshold;
+}
+
+/**
+ * Unconditional Branch
+ *
+ * @param tid Thread ID
+ * @param pc PC of branch
+ * @param bp_history update branch predictor history
+ */
+void
+GShareBP::uncondBranch(ThreadID tid, Addr pc, void *&bp_history)
+{
+    BPHistory *history = new BPHistory;
+    history->globalHistory = globalHistory[tid];
+    history->prediction = true;
+
+    bp_history = static_cast<void*>(history);
+    updateGlobalHistory(true);
+    return;
+}
+
+/**
+ * Updates the global history register.
+ *
+ * @param taken True if branch was taken, else false
+ */
+void
+GShareBP::updateGlobalHistory(bool taken)
+{
+    // TODO: Update the global history register
+}
+
+/**
+ * Returns the local history index, given a branch address.
+ * @param branch_addr The branch's PC address.
+ */
+inline
+unsigned
+GShareBP::calcLocHistIdx(Addr &branch_addr)
+{
+    // TODO: Calculate the local predictor index
+    // NOTE: Be sure to use instShiftAmt to shift the address to remove LSB
+    // zeros
+    return 0;
+}
+
+
+} // namespace branch_prediction
+} // namespace gem5
diff --git a/src/cpu/pred/gshare.hh b/src/cpu/pred/gshare.hh
new file mode 100644
index 000000000..fff83a6ad
--- /dev/null
+++ b/src/cpu/pred/gshare.hh
@@ -0,0 +1,123 @@
+#ifndef __CPU_PRED_GSHARE_HH__
+
+#define __CPU_PRED_GSHARE_HH__
+
+#include <vector>
+
+#include "base/sat_counter.hh"
+#include "base/types.hh"
+#include "cpu/pred/bpred_unit.hh"
+#include "params/GShareBP.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+/**
+ * Implements a local predictor that uses the PC to index into a table of
+ * counters.  Note that any time a pointer to the bp_history is given, it
+ * should be NULL using this predictor because it does not have any branch
+ * predictor state that needs to be recorded or updated; the update can be
+ * determined solely by the branch being taken or not taken.
+ */
+class GShareBP : public BPredUnit
+{
+  public:
+    /**
+     * Default branch predictor constructor.
+     */
+    GShareBP(const GShareBPParams &params);
+
+    virtual void uncondBranch(ThreadID tid, Addr pc, void * &bp_history);
+
+    /**
+     * Returns if the branch should be taken or not, given a counter
+     * value.
+     * @param count The counter value.
+     */
+    inline bool getPrediction(uint8_t &count);
+
+    /**
+     * Looks up the given address in the branch predictor and returns
+     * a true/false value as to whether it is taken.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer to any bp history state.
+     * @return Whether or not the branch is taken.
+     */
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Updates the branch predictor to Not Taken if a BTB entry is
+     * invalid or not found.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer to any bp history state.
+     * @return Whether or not the branch is taken.
+     */
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Updates the branch predictor with the actual result of a branch.
+     * @param branch_addr The address of the branch to update.
+     * @param taken Whether or not the branch was taken.
+     */
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr corrTarget);
+
+    void squash(ThreadID tid, void *bp_history)
+    { assert(bp_history == NULL); }
+
+  private:
+    /**
+     * Updates the global history register.
+     *
+     * @param taken True if branch was taken, else false
+     */
+    void updateGlobalHistory(bool taken);
+
+    /**
+     * Returns the local history index, given a branch address.
+     * @param branch_addr The branch's PC address.
+     */
+    inline unsigned calcLocHistIdx(Addr &branch_addr);
+
+    struct BPHistory {
+        unsigned globalHistory;  /**< Global history register */
+        bool prediction;            /**< True if taken, else false */
+    };
+
+    /** Number of counters in the local predictor. */
+    unsigned localPredictorSize;
+
+    /** Number of bits of the local predictor's counters. */
+    const unsigned localCtrBits;
+
+    /** Array of counters that make up the local predictor. */
+    std::vector<SatCounter8> localCtrs;
+
+    /** Global history register. Contains as much history as specified by
+     *  globalHistoryBits. Actual number of bits used is determined by
+     *  globalHistoryMask and choiceHistoryMask. */
+    std::vector<unsigned> globalHistory;
+
+    /** Number of bits for the global history. Determines maximum number of
+        entries in global and choice predictor tables. */
+    unsigned globalHistoryBits;
+
+    /** Mask to apply to globalHistory to access global history table.
+     *  Based on globalPredictorSize.*/
+    unsigned globalHistoryMask;
+
+
+    /** Thresholds for the counter value; above the threshold is taken,
+     *  equal to or below the threshold is not taken.
+     */
+    unsigned localThreshold;
+
+};
+
+} // namespace branch_prediction
+} // namespace gem5
+
+#endif // __CPU_PRED_GSHARE_PRED_HH__
